// Generated by gencpp from file ins_msg/EkfStatusMsg.msg
// DO NOT EDIT!


#ifndef INS_MSG_MESSAGE_EKFSTATUSMSG_H
#define INS_MSG_MESSAGE_EKFSTATUSMSG_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>

namespace ins_msg
{
template <class ContainerAllocator>
struct EkfStatusMsg_
{
  typedef EkfStatusMsg_<ContainerAllocator> Type;

  EkfStatusMsg_()
    : header()
    , utime(0)
    , ref()
    , obs()
    , out()
    , state_rpy()
    , state_vel()
    , state_pos()
    , state_gyro_bias()
    , state_acc_bias()
    , state_scale(0.0)
    , state_yaw_error(0.0)
    , state_pitch_error(0.0)
    , innov_speed()
    , innov_rtk_pos()
    , innov_rtk_vel()
    , innov_rtk_hdg(0.0)
    , R_speed()
    , R_rtk_pos()
    , R_rtk_vel()
    , R_rtk_hdg(0.0)
    , P()
    , speed_imu_time(0.0)
    , speed_rtk_time(0.0)
    , delta_imu_time(0.0)
    , msg_cnt(0)  {
      ref.assign(0.0);

      obs.assign(0.0);

      out.assign(0.0);

      state_rpy.assign(0.0);

      state_vel.assign(0.0);

      state_pos.assign(0.0);

      state_gyro_bias.assign(0.0);

      state_acc_bias.assign(0.0);

      innov_speed.assign(0.0);

      innov_rtk_pos.assign(0.0);

      innov_rtk_vel.assign(0.0);

      R_speed.assign(0.0);

      R_rtk_pos.assign(0.0);

      R_rtk_vel.assign(0.0);

      P.assign(0.0);
  }
  EkfStatusMsg_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , utime(0)
    , ref()
    , obs()
    , out()
    , state_rpy()
    , state_vel()
    , state_pos()
    , state_gyro_bias()
    , state_acc_bias()
    , state_scale(0.0)
    , state_yaw_error(0.0)
    , state_pitch_error(0.0)
    , innov_speed()
    , innov_rtk_pos()
    , innov_rtk_vel()
    , innov_rtk_hdg(0.0)
    , R_speed()
    , R_rtk_pos()
    , R_rtk_vel()
    , R_rtk_hdg(0.0)
    , P()
    , speed_imu_time(0.0)
    , speed_rtk_time(0.0)
    , delta_imu_time(0.0)
    , msg_cnt(0)  {
  (void)_alloc;
      ref.assign(0.0);

      obs.assign(0.0);

      out.assign(0.0);

      state_rpy.assign(0.0);

      state_vel.assign(0.0);

      state_pos.assign(0.0);

      state_gyro_bias.assign(0.0);

      state_acc_bias.assign(0.0);

      innov_speed.assign(0.0);

      innov_rtk_pos.assign(0.0);

      innov_rtk_vel.assign(0.0);

      R_speed.assign(0.0);

      R_rtk_pos.assign(0.0);

      R_rtk_vel.assign(0.0);

      P.assign(0.0);
  }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef int64_t _utime_type;
  _utime_type utime;

   typedef boost::array<double, 3>  _ref_type;
  _ref_type ref;

   typedef boost::array<double, 3>  _obs_type;
  _obs_type obs;

   typedef boost::array<double, 3>  _out_type;
  _out_type out;

   typedef boost::array<double, 3>  _state_rpy_type;
  _state_rpy_type state_rpy;

   typedef boost::array<double, 3>  _state_vel_type;
  _state_vel_type state_vel;

   typedef boost::array<double, 3>  _state_pos_type;
  _state_pos_type state_pos;

   typedef boost::array<double, 3>  _state_gyro_bias_type;
  _state_gyro_bias_type state_gyro_bias;

   typedef boost::array<double, 3>  _state_acc_bias_type;
  _state_acc_bias_type state_acc_bias;

   typedef double _state_scale_type;
  _state_scale_type state_scale;

   typedef double _state_yaw_error_type;
  _state_yaw_error_type state_yaw_error;

   typedef double _state_pitch_error_type;
  _state_pitch_error_type state_pitch_error;

   typedef boost::array<double, 3>  _innov_speed_type;
  _innov_speed_type innov_speed;

   typedef boost::array<double, 3>  _innov_rtk_pos_type;
  _innov_rtk_pos_type innov_rtk_pos;

   typedef boost::array<double, 3>  _innov_rtk_vel_type;
  _innov_rtk_vel_type innov_rtk_vel;

   typedef double _innov_rtk_hdg_type;
  _innov_rtk_hdg_type innov_rtk_hdg;

   typedef boost::array<double, 3>  _R_speed_type;
  _R_speed_type R_speed;

   typedef boost::array<double, 3>  _R_rtk_pos_type;
  _R_rtk_pos_type R_rtk_pos;

   typedef boost::array<double, 3>  _R_rtk_vel_type;
  _R_rtk_vel_type R_rtk_vel;

   typedef double _R_rtk_hdg_type;
  _R_rtk_hdg_type R_rtk_hdg;

   typedef boost::array<double, 18>  _P_type;
  _P_type P;

   typedef double _speed_imu_time_type;
  _speed_imu_time_type speed_imu_time;

   typedef double _speed_rtk_time_type;
  _speed_rtk_time_type speed_rtk_time;

   typedef double _delta_imu_time_type;
  _delta_imu_time_type delta_imu_time;

   typedef uint8_t _msg_cnt_type;
  _msg_cnt_type msg_cnt;





  typedef boost::shared_ptr< ::ins_msg::EkfStatusMsg_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::ins_msg::EkfStatusMsg_<ContainerAllocator> const> ConstPtr;

}; // struct EkfStatusMsg_

typedef ::ins_msg::EkfStatusMsg_<std::allocator<void> > EkfStatusMsg;

typedef boost::shared_ptr< ::ins_msg::EkfStatusMsg > EkfStatusMsgPtr;
typedef boost::shared_ptr< ::ins_msg::EkfStatusMsg const> EkfStatusMsgConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::ins_msg::EkfStatusMsg_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::ins_msg::EkfStatusMsg_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::ins_msg::EkfStatusMsg_<ContainerAllocator1> & lhs, const ::ins_msg::EkfStatusMsg_<ContainerAllocator2> & rhs)
{
  return lhs.header == rhs.header &&
    lhs.utime == rhs.utime &&
    lhs.ref == rhs.ref &&
    lhs.obs == rhs.obs &&
    lhs.out == rhs.out &&
    lhs.state_rpy == rhs.state_rpy &&
    lhs.state_vel == rhs.state_vel &&
    lhs.state_pos == rhs.state_pos &&
    lhs.state_gyro_bias == rhs.state_gyro_bias &&
    lhs.state_acc_bias == rhs.state_acc_bias &&
    lhs.state_scale == rhs.state_scale &&
    lhs.state_yaw_error == rhs.state_yaw_error &&
    lhs.state_pitch_error == rhs.state_pitch_error &&
    lhs.innov_speed == rhs.innov_speed &&
    lhs.innov_rtk_pos == rhs.innov_rtk_pos &&
    lhs.innov_rtk_vel == rhs.innov_rtk_vel &&
    lhs.innov_rtk_hdg == rhs.innov_rtk_hdg &&
    lhs.R_speed == rhs.R_speed &&
    lhs.R_rtk_pos == rhs.R_rtk_pos &&
    lhs.R_rtk_vel == rhs.R_rtk_vel &&
    lhs.R_rtk_hdg == rhs.R_rtk_hdg &&
    lhs.P == rhs.P &&
    lhs.speed_imu_time == rhs.speed_imu_time &&
    lhs.speed_rtk_time == rhs.speed_rtk_time &&
    lhs.delta_imu_time == rhs.delta_imu_time &&
    lhs.msg_cnt == rhs.msg_cnt;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::ins_msg::EkfStatusMsg_<ContainerAllocator1> & lhs, const ::ins_msg::EkfStatusMsg_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace ins_msg

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::ins_msg::EkfStatusMsg_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::ins_msg::EkfStatusMsg_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::ins_msg::EkfStatusMsg_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::ins_msg::EkfStatusMsg_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::ins_msg::EkfStatusMsg_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::ins_msg::EkfStatusMsg_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::ins_msg::EkfStatusMsg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "5158c32f409803affa7d895a54503ab0";
  }

  static const char* value(const ::ins_msg::EkfStatusMsg_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x5158c32f409803afULL;
  static const uint64_t static_value2 = 0xfa7d895a54503ab0ULL;
};

template<class ContainerAllocator>
struct DataType< ::ins_msg::EkfStatusMsg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "ins_msg/EkfStatusMsg";
  }

  static const char* value(const ::ins_msg::EkfStatusMsg_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::ins_msg::EkfStatusMsg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "Header header\n"
"\n"
"int64 utime\n"
"\n"
"float64[3] ref\n"
"float64[3] obs\n"
"float64[3] out\n"
"\n"
"float64[3] state_rpy\n"
"float64[3] state_vel\n"
"float64[3] state_pos\n"
"float64[3] state_gyro_bias\n"
"float64[3] state_acc_bias\n"
"float64 state_scale\n"
"float64 state_yaw_error\n"
"float64 state_pitch_error\n"
"\n"
"float64[3] innov_speed\n"
"float64[3] innov_rtk_pos\n"
"float64[3] innov_rtk_vel\n"
"float64 innov_rtk_hdg\n"
"\n"
"float64[3] R_speed\n"
"float64[3] R_rtk_pos\n"
"float64[3] R_rtk_vel\n"
"float64 R_rtk_hdg\n"
"\n"
"float64[18] P\n"
"\n"
"float64 speed_imu_time\n"
"float64 speed_rtk_time\n"
"float64 delta_imu_time\n"
"\n"
"uint8 msg_cnt\n"
"\n"
"\n"
"================================================================================\n"
"MSG: std_msgs/Header\n"
"# Standard metadata for higher-level stamped data types.\n"
"# This is generally used to communicate timestamped data \n"
"# in a particular coordinate frame.\n"
"# \n"
"# sequence ID: consecutively increasing ID \n"
"uint32 seq\n"
"#Two-integer timestamp that is expressed as:\n"
"# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n"
"# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n"
"# time-handling sugar is provided by the client library\n"
"time stamp\n"
"#Frame this data is associated with\n"
"string frame_id\n"
;
  }

  static const char* value(const ::ins_msg::EkfStatusMsg_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::ins_msg::EkfStatusMsg_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.utime);
      stream.next(m.ref);
      stream.next(m.obs);
      stream.next(m.out);
      stream.next(m.state_rpy);
      stream.next(m.state_vel);
      stream.next(m.state_pos);
      stream.next(m.state_gyro_bias);
      stream.next(m.state_acc_bias);
      stream.next(m.state_scale);
      stream.next(m.state_yaw_error);
      stream.next(m.state_pitch_error);
      stream.next(m.innov_speed);
      stream.next(m.innov_rtk_pos);
      stream.next(m.innov_rtk_vel);
      stream.next(m.innov_rtk_hdg);
      stream.next(m.R_speed);
      stream.next(m.R_rtk_pos);
      stream.next(m.R_rtk_vel);
      stream.next(m.R_rtk_hdg);
      stream.next(m.P);
      stream.next(m.speed_imu_time);
      stream.next(m.speed_rtk_time);
      stream.next(m.delta_imu_time);
      stream.next(m.msg_cnt);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct EkfStatusMsg_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::ins_msg::EkfStatusMsg_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::ins_msg::EkfStatusMsg_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "utime: ";
    Printer<int64_t>::stream(s, indent + "  ", v.utime);
    s << indent << "ref[]" << std::endl;
    for (size_t i = 0; i < v.ref.size(); ++i)
    {
      s << indent << "  ref[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.ref[i]);
    }
    s << indent << "obs[]" << std::endl;
    for (size_t i = 0; i < v.obs.size(); ++i)
    {
      s << indent << "  obs[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.obs[i]);
    }
    s << indent << "out[]" << std::endl;
    for (size_t i = 0; i < v.out.size(); ++i)
    {
      s << indent << "  out[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.out[i]);
    }
    s << indent << "state_rpy[]" << std::endl;
    for (size_t i = 0; i < v.state_rpy.size(); ++i)
    {
      s << indent << "  state_rpy[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.state_rpy[i]);
    }
    s << indent << "state_vel[]" << std::endl;
    for (size_t i = 0; i < v.state_vel.size(); ++i)
    {
      s << indent << "  state_vel[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.state_vel[i]);
    }
    s << indent << "state_pos[]" << std::endl;
    for (size_t i = 0; i < v.state_pos.size(); ++i)
    {
      s << indent << "  state_pos[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.state_pos[i]);
    }
    s << indent << "state_gyro_bias[]" << std::endl;
    for (size_t i = 0; i < v.state_gyro_bias.size(); ++i)
    {
      s << indent << "  state_gyro_bias[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.state_gyro_bias[i]);
    }
    s << indent << "state_acc_bias[]" << std::endl;
    for (size_t i = 0; i < v.state_acc_bias.size(); ++i)
    {
      s << indent << "  state_acc_bias[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.state_acc_bias[i]);
    }
    s << indent << "state_scale: ";
    Printer<double>::stream(s, indent + "  ", v.state_scale);
    s << indent << "state_yaw_error: ";
    Printer<double>::stream(s, indent + "  ", v.state_yaw_error);
    s << indent << "state_pitch_error: ";
    Printer<double>::stream(s, indent + "  ", v.state_pitch_error);
    s << indent << "innov_speed[]" << std::endl;
    for (size_t i = 0; i < v.innov_speed.size(); ++i)
    {
      s << indent << "  innov_speed[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.innov_speed[i]);
    }
    s << indent << "innov_rtk_pos[]" << std::endl;
    for (size_t i = 0; i < v.innov_rtk_pos.size(); ++i)
    {
      s << indent << "  innov_rtk_pos[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.innov_rtk_pos[i]);
    }
    s << indent << "innov_rtk_vel[]" << std::endl;
    for (size_t i = 0; i < v.innov_rtk_vel.size(); ++i)
    {
      s << indent << "  innov_rtk_vel[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.innov_rtk_vel[i]);
    }
    s << indent << "innov_rtk_hdg: ";
    Printer<double>::stream(s, indent + "  ", v.innov_rtk_hdg);
    s << indent << "R_speed[]" << std::endl;
    for (size_t i = 0; i < v.R_speed.size(); ++i)
    {
      s << indent << "  R_speed[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.R_speed[i]);
    }
    s << indent << "R_rtk_pos[]" << std::endl;
    for (size_t i = 0; i < v.R_rtk_pos.size(); ++i)
    {
      s << indent << "  R_rtk_pos[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.R_rtk_pos[i]);
    }
    s << indent << "R_rtk_vel[]" << std::endl;
    for (size_t i = 0; i < v.R_rtk_vel.size(); ++i)
    {
      s << indent << "  R_rtk_vel[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.R_rtk_vel[i]);
    }
    s << indent << "R_rtk_hdg: ";
    Printer<double>::stream(s, indent + "  ", v.R_rtk_hdg);
    s << indent << "P[]" << std::endl;
    for (size_t i = 0; i < v.P.size(); ++i)
    {
      s << indent << "  P[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.P[i]);
    }
    s << indent << "speed_imu_time: ";
    Printer<double>::stream(s, indent + "  ", v.speed_imu_time);
    s << indent << "speed_rtk_time: ";
    Printer<double>::stream(s, indent + "  ", v.speed_rtk_time);
    s << indent << "delta_imu_time: ";
    Printer<double>::stream(s, indent + "  ", v.delta_imu_time);
    s << indent << "msg_cnt: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.msg_cnt);
  }
};

} // namespace message_operations
} // namespace ros

#endif // INS_MSG_MESSAGE_EKFSTATUSMSG_H
